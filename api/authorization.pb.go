// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        (unknown)
// source: authorization.proto

package api

import (
	_ "google.golang.org/genproto/googleapis/api/annotations"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// CheckRequest represents a single authorization check
type CheckRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The namespace of the object being checked
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// The ID of the object being checked
	ObjectId string `protobuf:"bytes,2,opt,name=object_id,json=objectId,proto3" json:"object_id,omitempty"`
	// The relation/permission being checked
	Relation string `protobuf:"bytes,3,opt,name=relation,proto3" json:"relation,omitempty"`
	// The user ID to check permissions for
	UserId string `protobuf:"bytes,4,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// Optional consistency token for causally consistent reads
	ConsistencyToken string `protobuf:"bytes,5,opt,name=consistency_token,json=consistencyToken,proto3" json:"consistency_token,omitempty"`
	// Optional context for conditional permissions
	Context       map[string]string `protobuf:"bytes,6,rep,name=context,proto3" json:"context,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CheckRequest) Reset() {
	*x = CheckRequest{}
	mi := &file_authorization_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CheckRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CheckRequest) ProtoMessage() {}

func (x *CheckRequest) ProtoReflect() protoreflect.Message {
	mi := &file_authorization_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CheckRequest.ProtoReflect.Descriptor instead.
func (*CheckRequest) Descriptor() ([]byte, []int) {
	return file_authorization_proto_rawDescGZIP(), []int{0}
}

func (x *CheckRequest) GetNamespace() string {
	if x != nil {
		return x.Namespace
	}
	return ""
}

func (x *CheckRequest) GetObjectId() string {
	if x != nil {
		return x.ObjectId
	}
	return ""
}

func (x *CheckRequest) GetRelation() string {
	if x != nil {
		return x.Relation
	}
	return ""
}

func (x *CheckRequest) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

func (x *CheckRequest) GetConsistencyToken() string {
	if x != nil {
		return x.ConsistencyToken
	}
	return ""
}

func (x *CheckRequest) GetContext() map[string]string {
	if x != nil {
		return x.Context
	}
	return nil
}

// CheckResponse contains the result of an authorization check
type CheckResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Whether the user has the requested permission
	Allowed bool `protobuf:"varint,1,opt,name=allowed,proto3" json:"allowed,omitempty"`
	// Consistency token for subsequent operations
	ConsistencyToken string `protobuf:"bytes,2,opt,name=consistency_token,json=consistencyToken,proto3" json:"consistency_token,omitempty"`
	// When this check was performed
	CheckedAt *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=checked_at,json=checkedAt,proto3" json:"checked_at,omitempty"`
	// Optional debug information (only included in debug mode)
	DebugInfo     *DebugInfo `protobuf:"bytes,4,opt,name=debug_info,json=debugInfo,proto3" json:"debug_info,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CheckResponse) Reset() {
	*x = CheckResponse{}
	mi := &file_authorization_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CheckResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CheckResponse) ProtoMessage() {}

func (x *CheckResponse) ProtoReflect() protoreflect.Message {
	mi := &file_authorization_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CheckResponse.ProtoReflect.Descriptor instead.
func (*CheckResponse) Descriptor() ([]byte, []int) {
	return file_authorization_proto_rawDescGZIP(), []int{1}
}

func (x *CheckResponse) GetAllowed() bool {
	if x != nil {
		return x.Allowed
	}
	return false
}

func (x *CheckResponse) GetConsistencyToken() string {
	if x != nil {
		return x.ConsistencyToken
	}
	return ""
}

func (x *CheckResponse) GetCheckedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.CheckedAt
	}
	return nil
}

func (x *CheckResponse) GetDebugInfo() *DebugInfo {
	if x != nil {
		return x.DebugInfo
	}
	return nil
}

// ExpandRequest asks for expansion of a userset
type ExpandRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The namespace of the object
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// The object ID
	ObjectId string `protobuf:"bytes,2,opt,name=object_id,json=objectId,proto3" json:"object_id,omitempty"`
	// The relation to expand
	Relation string `protobuf:"bytes,3,opt,name=relation,proto3" json:"relation,omitempty"`
	// Optional consistency token
	ConsistencyToken string `protobuf:"bytes,4,opt,name=consistency_token,json=consistencyToken,proto3" json:"consistency_token,omitempty"`
	// Maximum depth to expand (prevents infinite recursion)
	MaxDepth      int32 `protobuf:"varint,5,opt,name=max_depth,json=maxDepth,proto3" json:"max_depth,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExpandRequest) Reset() {
	*x = ExpandRequest{}
	mi := &file_authorization_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExpandRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExpandRequest) ProtoMessage() {}

func (x *ExpandRequest) ProtoReflect() protoreflect.Message {
	mi := &file_authorization_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExpandRequest.ProtoReflect.Descriptor instead.
func (*ExpandRequest) Descriptor() ([]byte, []int) {
	return file_authorization_proto_rawDescGZIP(), []int{2}
}

func (x *ExpandRequest) GetNamespace() string {
	if x != nil {
		return x.Namespace
	}
	return ""
}

func (x *ExpandRequest) GetObjectId() string {
	if x != nil {
		return x.ObjectId
	}
	return ""
}

func (x *ExpandRequest) GetRelation() string {
	if x != nil {
		return x.Relation
	}
	return ""
}

func (x *ExpandRequest) GetConsistencyToken() string {
	if x != nil {
		return x.ConsistencyToken
	}
	return ""
}

func (x *ExpandRequest) GetMaxDepth() int32 {
	if x != nil {
		return x.MaxDepth
	}
	return 0
}

// ExpandResponse contains the expanded userset
type ExpandResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The expanded userset tree
	Userset *UserSet `protobuf:"bytes,1,opt,name=userset,proto3" json:"userset,omitempty"`
	// Consistency token
	ConsistencyToken string `protobuf:"bytes,2,opt,name=consistency_token,json=consistencyToken,proto3" json:"consistency_token,omitempty"`
	// When this expansion was performed
	ExpandedAt    *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=expanded_at,json=expandedAt,proto3" json:"expanded_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExpandResponse) Reset() {
	*x = ExpandResponse{}
	mi := &file_authorization_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExpandResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExpandResponse) ProtoMessage() {}

func (x *ExpandResponse) ProtoReflect() protoreflect.Message {
	mi := &file_authorization_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExpandResponse.ProtoReflect.Descriptor instead.
func (*ExpandResponse) Descriptor() ([]byte, []int) {
	return file_authorization_proto_rawDescGZIP(), []int{3}
}

func (x *ExpandResponse) GetUserset() *UserSet {
	if x != nil {
		return x.Userset
	}
	return nil
}

func (x *ExpandResponse) GetConsistencyToken() string {
	if x != nil {
		return x.ConsistencyToken
	}
	return ""
}

func (x *ExpandResponse) GetExpandedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.ExpandedAt
	}
	return nil
}

// ListPermissionsRequest asks for all permissions of a user
type ListPermissionsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The user ID to list permissions for
	UserId string `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// Optional namespace filter
	Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Optional object ID filter
	ObjectId string `protobuf:"bytes,3,opt,name=object_id,json=objectId,proto3" json:"object_id,omitempty"`
	// Optional consistency token
	ConsistencyToken string `protobuf:"bytes,4,opt,name=consistency_token,json=consistencyToken,proto3" json:"consistency_token,omitempty"`
	// Pagination token
	PageToken string `protobuf:"bytes,5,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	// Maximum number of permissions to return
	PageSize      int32 `protobuf:"varint,6,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListPermissionsRequest) Reset() {
	*x = ListPermissionsRequest{}
	mi := &file_authorization_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListPermissionsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListPermissionsRequest) ProtoMessage() {}

func (x *ListPermissionsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_authorization_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListPermissionsRequest.ProtoReflect.Descriptor instead.
func (*ListPermissionsRequest) Descriptor() ([]byte, []int) {
	return file_authorization_proto_rawDescGZIP(), []int{4}
}

func (x *ListPermissionsRequest) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

func (x *ListPermissionsRequest) GetNamespace() string {
	if x != nil {
		return x.Namespace
	}
	return ""
}

func (x *ListPermissionsRequest) GetObjectId() string {
	if x != nil {
		return x.ObjectId
	}
	return ""
}

func (x *ListPermissionsRequest) GetConsistencyToken() string {
	if x != nil {
		return x.ConsistencyToken
	}
	return ""
}

func (x *ListPermissionsRequest) GetPageToken() string {
	if x != nil {
		return x.PageToken
	}
	return ""
}

func (x *ListPermissionsRequest) GetPageSize() int32 {
	if x != nil {
		return x.PageSize
	}
	return 0
}

// ListPermissionsResponse contains the user's permissions
type ListPermissionsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The permissions the user has
	Permissions []*Permission `protobuf:"bytes,1,rep,name=permissions,proto3" json:"permissions,omitempty"`
	// Token for next page of results
	NextPageToken string `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	// Consistency token
	ConsistencyToken string `protobuf:"bytes,3,opt,name=consistency_token,json=consistencyToken,proto3" json:"consistency_token,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *ListPermissionsResponse) Reset() {
	*x = ListPermissionsResponse{}
	mi := &file_authorization_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListPermissionsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListPermissionsResponse) ProtoMessage() {}

func (x *ListPermissionsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_authorization_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListPermissionsResponse.ProtoReflect.Descriptor instead.
func (*ListPermissionsResponse) Descriptor() ([]byte, []int) {
	return file_authorization_proto_rawDescGZIP(), []int{5}
}

func (x *ListPermissionsResponse) GetPermissions() []*Permission {
	if x != nil {
		return x.Permissions
	}
	return nil
}

func (x *ListPermissionsResponse) GetNextPageToken() string {
	if x != nil {
		return x.NextPageToken
	}
	return ""
}

func (x *ListPermissionsResponse) GetConsistencyToken() string {
	if x != nil {
		return x.ConsistencyToken
	}
	return ""
}

// BatchCheckRequest allows checking multiple permissions at once
type BatchCheckRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of checks to perform
	Checks []*CheckRequest `protobuf:"bytes,1,rep,name=checks,proto3" json:"checks,omitempty"`
	// Optional consistency token that applies to all checks
	ConsistencyToken string `protobuf:"bytes,2,opt,name=consistency_token,json=consistencyToken,proto3" json:"consistency_token,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *BatchCheckRequest) Reset() {
	*x = BatchCheckRequest{}
	mi := &file_authorization_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BatchCheckRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchCheckRequest) ProtoMessage() {}

func (x *BatchCheckRequest) ProtoReflect() protoreflect.Message {
	mi := &file_authorization_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatchCheckRequest.ProtoReflect.Descriptor instead.
func (*BatchCheckRequest) Descriptor() ([]byte, []int) {
	return file_authorization_proto_rawDescGZIP(), []int{6}
}

func (x *BatchCheckRequest) GetChecks() []*CheckRequest {
	if x != nil {
		return x.Checks
	}
	return nil
}

func (x *BatchCheckRequest) GetConsistencyToken() string {
	if x != nil {
		return x.ConsistencyToken
	}
	return ""
}

// BatchCheckResponse contains results for all checks
type BatchCheckResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Results for each check in the same order as the request
	Results []*CheckResponse `protobuf:"bytes,1,rep,name=results,proto3" json:"results,omitempty"`
	// Consistency token for subsequent operations
	ConsistencyToken string `protobuf:"bytes,2,opt,name=consistency_token,json=consistencyToken,proto3" json:"consistency_token,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *BatchCheckResponse) Reset() {
	*x = BatchCheckResponse{}
	mi := &file_authorization_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BatchCheckResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchCheckResponse) ProtoMessage() {}

func (x *BatchCheckResponse) ProtoReflect() protoreflect.Message {
	mi := &file_authorization_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatchCheckResponse.ProtoReflect.Descriptor instead.
func (*BatchCheckResponse) Descriptor() ([]byte, []int) {
	return file_authorization_proto_rawDescGZIP(), []int{7}
}

func (x *BatchCheckResponse) GetResults() []*CheckResponse {
	if x != nil {
		return x.Results
	}
	return nil
}

func (x *BatchCheckResponse) GetConsistencyToken() string {
	if x != nil {
		return x.ConsistencyToken
	}
	return ""
}

// DebugInfo provides additional information for debugging authorization decisions
type DebugInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The resolution path taken to reach the decision
	ResolutionPath []string `protobuf:"bytes,1,rep,name=resolution_path,json=resolutionPath,proto3" json:"resolution_path,omitempty"`
	// Time taken to resolve the check
	ResolutionTimeMs int64 `protobuf:"varint,2,opt,name=resolution_time_ms,json=resolutionTimeMs,proto3" json:"resolution_time_ms,omitempty"`
	// Whether the result came from cache
	FromCache bool `protobuf:"varint,3,opt,name=from_cache,json=fromCache,proto3" json:"from_cache,omitempty"`
	// Additional debug metadata
	Metadata      map[string]string `protobuf:"bytes,4,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DebugInfo) Reset() {
	*x = DebugInfo{}
	mi := &file_authorization_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DebugInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DebugInfo) ProtoMessage() {}

func (x *DebugInfo) ProtoReflect() protoreflect.Message {
	mi := &file_authorization_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DebugInfo.ProtoReflect.Descriptor instead.
func (*DebugInfo) Descriptor() ([]byte, []int) {
	return file_authorization_proto_rawDescGZIP(), []int{8}
}

func (x *DebugInfo) GetResolutionPath() []string {
	if x != nil {
		return x.ResolutionPath
	}
	return nil
}

func (x *DebugInfo) GetResolutionTimeMs() int64 {
	if x != nil {
		return x.ResolutionTimeMs
	}
	return 0
}

func (x *DebugInfo) GetFromCache() bool {
	if x != nil {
		return x.FromCache
	}
	return false
}

func (x *DebugInfo) GetMetadata() map[string]string {
	if x != nil {
		return x.Metadata
	}
	return nil
}

var File_authorization_proto protoreflect.FileDescriptor

const file_authorization_proto_rawDesc = "" +
	"\n" +
	"\x13authorization.proto\x12\bgoacl.v1\x1a\x1cgoogle/api/annotations.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\vtypes.proto\"\xa6\x02\n" +
	"\fCheckRequest\x12\x1c\n" +
	"\tnamespace\x18\x01 \x01(\tR\tnamespace\x12\x1b\n" +
	"\tobject_id\x18\x02 \x01(\tR\bobjectId\x12\x1a\n" +
	"\brelation\x18\x03 \x01(\tR\brelation\x12\x17\n" +
	"\auser_id\x18\x04 \x01(\tR\x06userId\x12+\n" +
	"\x11consistency_token\x18\x05 \x01(\tR\x10consistencyToken\x12=\n" +
	"\acontext\x18\x06 \x03(\v2#.goacl.v1.CheckRequest.ContextEntryR\acontext\x1a:\n" +
	"\fContextEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xc5\x01\n" +
	"\rCheckResponse\x12\x18\n" +
	"\aallowed\x18\x01 \x01(\bR\aallowed\x12+\n" +
	"\x11consistency_token\x18\x02 \x01(\tR\x10consistencyToken\x129\n" +
	"\n" +
	"checked_at\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\tcheckedAt\x122\n" +
	"\n" +
	"debug_info\x18\x04 \x01(\v2\x13.goacl.v1.DebugInfoR\tdebugInfo\"\xb0\x01\n" +
	"\rExpandRequest\x12\x1c\n" +
	"\tnamespace\x18\x01 \x01(\tR\tnamespace\x12\x1b\n" +
	"\tobject_id\x18\x02 \x01(\tR\bobjectId\x12\x1a\n" +
	"\brelation\x18\x03 \x01(\tR\brelation\x12+\n" +
	"\x11consistency_token\x18\x04 \x01(\tR\x10consistencyToken\x12\x1b\n" +
	"\tmax_depth\x18\x05 \x01(\x05R\bmaxDepth\"\xa7\x01\n" +
	"\x0eExpandResponse\x12+\n" +
	"\auserset\x18\x01 \x01(\v2\x11.goacl.v1.UserSetR\auserset\x12+\n" +
	"\x11consistency_token\x18\x02 \x01(\tR\x10consistencyToken\x12;\n" +
	"\vexpanded_at\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"expandedAt\"\xd5\x01\n" +
	"\x16ListPermissionsRequest\x12\x17\n" +
	"\auser_id\x18\x01 \x01(\tR\x06userId\x12\x1c\n" +
	"\tnamespace\x18\x02 \x01(\tR\tnamespace\x12\x1b\n" +
	"\tobject_id\x18\x03 \x01(\tR\bobjectId\x12+\n" +
	"\x11consistency_token\x18\x04 \x01(\tR\x10consistencyToken\x12\x1d\n" +
	"\n" +
	"page_token\x18\x05 \x01(\tR\tpageToken\x12\x1b\n" +
	"\tpage_size\x18\x06 \x01(\x05R\bpageSize\"\xa6\x01\n" +
	"\x17ListPermissionsResponse\x126\n" +
	"\vpermissions\x18\x01 \x03(\v2\x14.goacl.v1.PermissionR\vpermissions\x12&\n" +
	"\x0fnext_page_token\x18\x02 \x01(\tR\rnextPageToken\x12+\n" +
	"\x11consistency_token\x18\x03 \x01(\tR\x10consistencyToken\"p\n" +
	"\x11BatchCheckRequest\x12.\n" +
	"\x06checks\x18\x01 \x03(\v2\x16.goacl.v1.CheckRequestR\x06checks\x12+\n" +
	"\x11consistency_token\x18\x02 \x01(\tR\x10consistencyToken\"t\n" +
	"\x12BatchCheckResponse\x121\n" +
	"\aresults\x18\x01 \x03(\v2\x17.goacl.v1.CheckResponseR\aresults\x12+\n" +
	"\x11consistency_token\x18\x02 \x01(\tR\x10consistencyToken\"\xfd\x01\n" +
	"\tDebugInfo\x12'\n" +
	"\x0fresolution_path\x18\x01 \x03(\tR\x0eresolutionPath\x12,\n" +
	"\x12resolution_time_ms\x18\x02 \x01(\x03R\x10resolutionTimeMs\x12\x1d\n" +
	"\n" +
	"from_cache\x18\x03 \x01(\bR\tfromCache\x12=\n" +
	"\bmetadata\x18\x04 \x03(\v2!.goacl.v1.DebugInfo.MetadataEntryR\bmetadata\x1a;\n" +
	"\rMetadataEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x012\xa0\x03\n" +
	"\x14AuthorizationService\x12N\n" +
	"\x05Check\x12\x16.goacl.v1.CheckRequest\x1a\x17.goacl.v1.CheckResponse\"\x14\x82\xd3\xe4\x93\x02\x0e:\x01*\"\t/v1/check\x12R\n" +
	"\x06Expand\x12\x17.goacl.v1.ExpandRequest\x1a\x18.goacl.v1.ExpandResponse\"\x15\x82\xd3\xe4\x93\x02\x0f:\x01*\"\n" +
	"/v1/expand\x12\x7f\n" +
	"\x0fListPermissions\x12 .goacl.v1.ListPermissionsRequest\x1a!.goacl.v1.ListPermissionsResponse\"'\x82\xd3\xe4\x93\x02!\x12\x1f/v1/users/{user_id}/permissions\x12c\n" +
	"\n" +
	"BatchCheck\x12\x1b.goacl.v1.BatchCheckRequest\x1a\x1c.goacl.v1.BatchCheckResponse\"\x1a\x82\xd3\xe4\x93\x02\x14:\x01*\"\x0f/v1/check/batchB\x84\x01\n" +
	"\fcom.goacl.v1B\x12AuthorizationProtoP\x01Z\x1fgithub.com/DangVTNhan/goacl/api\xa2\x02\x03GXX\xaa\x02\bGoacl.V1\xca\x02\bGoacl\\V1\xe2\x02\x14Goacl\\V1\\GPBMetadata\xea\x02\tGoacl::V1b\x06proto3"

var (
	file_authorization_proto_rawDescOnce sync.Once
	file_authorization_proto_rawDescData []byte
)

func file_authorization_proto_rawDescGZIP() []byte {
	file_authorization_proto_rawDescOnce.Do(func() {
		file_authorization_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_authorization_proto_rawDesc), len(file_authorization_proto_rawDesc)))
	})
	return file_authorization_proto_rawDescData
}

var file_authorization_proto_msgTypes = make([]protoimpl.MessageInfo, 11)
var file_authorization_proto_goTypes = []any{
	(*CheckRequest)(nil),            // 0: goacl.v1.CheckRequest
	(*CheckResponse)(nil),           // 1: goacl.v1.CheckResponse
	(*ExpandRequest)(nil),           // 2: goacl.v1.ExpandRequest
	(*ExpandResponse)(nil),          // 3: goacl.v1.ExpandResponse
	(*ListPermissionsRequest)(nil),  // 4: goacl.v1.ListPermissionsRequest
	(*ListPermissionsResponse)(nil), // 5: goacl.v1.ListPermissionsResponse
	(*BatchCheckRequest)(nil),       // 6: goacl.v1.BatchCheckRequest
	(*BatchCheckResponse)(nil),      // 7: goacl.v1.BatchCheckResponse
	(*DebugInfo)(nil),               // 8: goacl.v1.DebugInfo
	nil,                             // 9: goacl.v1.CheckRequest.ContextEntry
	nil,                             // 10: goacl.v1.DebugInfo.MetadataEntry
	(*timestamppb.Timestamp)(nil),   // 11: google.protobuf.Timestamp
	(*UserSet)(nil),                 // 12: goacl.v1.UserSet
	(*Permission)(nil),              // 13: goacl.v1.Permission
}
var file_authorization_proto_depIdxs = []int32{
	9,  // 0: goacl.v1.CheckRequest.context:type_name -> goacl.v1.CheckRequest.ContextEntry
	11, // 1: goacl.v1.CheckResponse.checked_at:type_name -> google.protobuf.Timestamp
	8,  // 2: goacl.v1.CheckResponse.debug_info:type_name -> goacl.v1.DebugInfo
	12, // 3: goacl.v1.ExpandResponse.userset:type_name -> goacl.v1.UserSet
	11, // 4: goacl.v1.ExpandResponse.expanded_at:type_name -> google.protobuf.Timestamp
	13, // 5: goacl.v1.ListPermissionsResponse.permissions:type_name -> goacl.v1.Permission
	0,  // 6: goacl.v1.BatchCheckRequest.checks:type_name -> goacl.v1.CheckRequest
	1,  // 7: goacl.v1.BatchCheckResponse.results:type_name -> goacl.v1.CheckResponse
	10, // 8: goacl.v1.DebugInfo.metadata:type_name -> goacl.v1.DebugInfo.MetadataEntry
	0,  // 9: goacl.v1.AuthorizationService.Check:input_type -> goacl.v1.CheckRequest
	2,  // 10: goacl.v1.AuthorizationService.Expand:input_type -> goacl.v1.ExpandRequest
	4,  // 11: goacl.v1.AuthorizationService.ListPermissions:input_type -> goacl.v1.ListPermissionsRequest
	6,  // 12: goacl.v1.AuthorizationService.BatchCheck:input_type -> goacl.v1.BatchCheckRequest
	1,  // 13: goacl.v1.AuthorizationService.Check:output_type -> goacl.v1.CheckResponse
	3,  // 14: goacl.v1.AuthorizationService.Expand:output_type -> goacl.v1.ExpandResponse
	5,  // 15: goacl.v1.AuthorizationService.ListPermissions:output_type -> goacl.v1.ListPermissionsResponse
	7,  // 16: goacl.v1.AuthorizationService.BatchCheck:output_type -> goacl.v1.BatchCheckResponse
	13, // [13:17] is the sub-list for method output_type
	9,  // [9:13] is the sub-list for method input_type
	9,  // [9:9] is the sub-list for extension type_name
	9,  // [9:9] is the sub-list for extension extendee
	0,  // [0:9] is the sub-list for field type_name
}

func init() { file_authorization_proto_init() }
func file_authorization_proto_init() {
	if File_authorization_proto != nil {
		return
	}
	file_types_proto_init()
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_authorization_proto_rawDesc), len(file_authorization_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   11,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_authorization_proto_goTypes,
		DependencyIndexes: file_authorization_proto_depIdxs,
		MessageInfos:      file_authorization_proto_msgTypes,
	}.Build()
	File_authorization_proto = out.File
	file_authorization_proto_goTypes = nil
	file_authorization_proto_depIdxs = nil
}
